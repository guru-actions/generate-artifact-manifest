apiVersion: automation.cloudbees.io/v1alpha1
kind: action
name: generate-artifact-manifest
description: Generates a YAML manifest of latest artifacts for a list of components.

inputs:
  cb_api_url:
    required: true
  cb_pat:
    required: true
  component_ids:
    required: true
    description: Comma-separated list of component IDs (e.g. id1,id2)
  labels:
    required: true
    description: Label filters to apply (e.g. rel=squid-ui,ns=squid-prod)

outputs:
  manifest:
    description: YAML-formatted artifact manifest with IDs, versions, timestamps, and names
    value: ${{ steps.generate.outputs.manifest }}
  errors:
    description: JSON-formatted list of components that failed to fetch or match
    value: ${{ steps.generate.outputs.errors }}

runs:
  using: composite
  steps:
    - id: generate
      name: Generate artifact manifest
      uses: docker://python:3.11-alpine
      shell: sh
      env:
        CB_API_URL: ${{ inputs.cb_api_url }}
        CB_PAT: ${{ inputs.cb_pat }}
        COMPONENT_IDS: ${{ inputs.component_ids }}
        LABELS: ${{ inputs.labels }}
      run: |
        apk add --no-cache curl jq yq > /dev/null

        echo "üîç Fetching latest artifacts for: $COMPONENT_IDS"
        : > manifest.yaml
        echo '{"errors":[]}' > errors.json
        echo "üîç Created blank manifest and error file"

        # Build a jq filter that tolerates missing labels:
        # Each label filter becomes: ((.labels // []) | index("k=v"))
        # Joined with AND so all labels must be present.
        FILTER=$(echo "$LABELS" | awk -F, '
          BEGIN { first=1 }
          {
            for (i = 1; i <= NF; i++) {
              if ($i == "") continue
              split($i, kv, "=")
              if (!first) { printf " and " }
              printf "(((.labels // []) | index(\"%s=%s\")))", kv[1], kv[2]
              first=0
            }
          }')

        if [ -z "$FILTER" ]; then
          echo "‚ÑπÔ∏è  No labels provided after parsing; defaulting to match-any artifact"
          FILTER="true"
        fi

        echo "üîç Filtering artifacts by labels: $LABELS"
        echo "üßÆ Using jq filter: $FILTER"

        for COMPONENT_ID in $(echo "$COMPONENT_IDS" | tr ',' ' '); do
          echo "üì¶ Fetching for component: $COMPONENT_ID"
          STATUS=$(curl -s -w "%{http_code}" -o response.json \
            -H "Authorization: Bearer $CB_PAT" \
            "$CB_API_URL/v3/components/$COMPONENT_ID/artifactinfos")

          if [ "$STATUS" -ne 200 ]; then
            echo "‚ùå Component fetch failed for $COMPONENT_ID (HTTP $STATUS)"
            jq --arg id "$COMPONENT_ID" --arg status "$STATUS" \
              '.errors += [{"component_id": $id, "status": ($status | tonumber), "message": "Component fetch failed"}]' \
              errors.json > tmp.json && mv tmp.json errors.json

            # Still emit a manifest entry so consumers see the component
            {
              echo "$COMPONENT_ID:"
              echo "  artifact_id: null"
              echo "  version: null"
              echo "  timestamp: null"
              echo "  artifact_name: null"
            } >> manifest.yaml

            continue
          fi

          # Safe jq: tolerate missing arrays/labels; never hard-fail on jq errors.
          MATCH=$(jq -r ".artifacts // [] | .[] | select($FILTER) | \"\(.id) \(.version) \(.publishedOn) \(.name)\"" response.json 2>/dev/null | head -n 1 || true)

          if [ -z "$MATCH" ]; then
            echo "‚ö†Ô∏è  No matching artifact found for $COMPONENT_ID (labels: $LABELS)"
            {
              echo "$COMPONENT_ID:"
              echo "  artifact_id: null"
              echo "  version: null"
              echo "  timestamp: null"
              echo "  artifact_name: null"
            } >> manifest.yaml

            # Record a structured non-fatal error for visibility
            jq --arg id "$COMPONENT_ID" --arg labels "$LABELS" \
              '.errors += [{"component_id": $id, "status": 200, "message": ("No artifact matched labels: " + $labels)}]' \
              errors.json > tmp.json && mv tmp.json errors.json
            continue
          fi

          ARTIFACT_ID=$(echo "$MATCH" | awk '{print $1}')
          VERSION=$(echo "$MATCH" | awk '{print $2}')
          TIMESTAMP=$(echo "$MATCH" | awk '{print $3}')
          ARTIFACT_NAME=$(echo "$MATCH" | cut -d' ' -f4-)

          {
            echo "$COMPONENT_ID:"
            echo "  artifact_id: \"$ARTIFACT_ID\""
            echo "  version: \"$VERSION\""
            echo "  timestamp: \"$TIMESTAMP\""
            echo "  artifact_name: \"$ARTIFACT_NAME\""
          } >> manifest.yaml
        done

        echo "‚úÖ Final Manifest:"
        cat manifest.yaml
        echo "üìã Final Errors:"
        cat errors.json

        # Write outputs
        cat manifest.yaml > "$CLOUDBEES_OUTPUTS/manifest"
        cat errors.json > "$CLOUDBEES_OUTPUTS/errors"
