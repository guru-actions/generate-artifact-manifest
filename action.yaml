apiVersion: automation.cloudbees.io/v1alpha1
kind: action
name: generate-artifact-manifest
description: Generates a YAML manifest of latest artifacts for a list of components.

inputs:
  cb_api_url:
    required: true
  cb_pat:
    required: true
  component_ids:
    required: true
    description: Comma-separated list of component IDs (e.g. id1,id2)
  labels:
    required: true
    description: Label filters to apply (e.g. rel=squid-ui,ns=squid-prod)
  org_id:
    required: false
    description: Optional organization ID for org-scoped component lookups

outputs:
  manifest:
    description: YAML-formatted artifact manifest with IDs, versions, timestamps, artifact names, component names, and match status
    value: ${{ steps.generate.outputs.manifest }}
  errors:
    description: JSON-formatted list of components that failed to fetch or match (and name-lookup diagnostics)
    value: ${{ steps.generate.outputs.errors }}

runs:
  using: composite
  steps:
    - id: generate
      name: Generate artifact manifest
      uses: docker://python:3.11-alpine
      shell: sh
      env:
        CB_API_URL: ${{ inputs.cb_api_url }}
        CB_PAT: ${{ inputs.cb_pat }}
        COMPONENT_IDS: ${{ inputs.component_ids }}
        LABELS: ${{ inputs.labels }}
        ORG_ID: ${{ inputs.org_id }}
      run: |
        set -eu
        # NOTE: keep -e for logic, but we'll disable it around the final printing.
        apk add --no-cache curl jq yq coreutils > /dev/null

        echo "üîç Fetching latest artifacts for: $COMPONENT_IDS"
        : > manifest.yaml
        echo '{"errors":[]}' > errors.json
        mkdir -p .cache
        echo "üîç Created blank manifest, error file, and cache dir"

        # Timing helper (ms since epoch)
        now_ms() { date +%s%3N; }  # requires coreutils 'date'

        # Timed curl: timed_curl <url> <outfile> -> echoes "<status> <duration_ms>"
        timed_curl() {
          _url="$1"; _out="$2"
          local t0 t1 dt status
          t0=$(now_ms)
          status=$(curl -s -w "%{http_code}" -o "$_out" \
            -H "Authorization: Bearer $CB_PAT" \
            -H "Accept: application/json" \
            "$_url")
          t1=$(now_ms); dt=$((t1 - t0))
          printf "%s %s" "$status" "$dt"
        }

        # Build a jq filter that tolerates missing labels:
        FILTER=$(echo "$LABELS" | awk -F, '
          BEGIN { first=1 }
          {
            for (i = 1; i <= NF; i++) {
              if ($i == "") continue
              split($i, kv, "=")
              if (!first) { printf " and " }
              printf "(((.labels // []) | index(\"%s=%s\")))", kv[1], kv[2]
              first=0
            }
          }')

        if [ -z "$FILTER" ]; then
          echo "‚ÑπÔ∏è  No labels provided after parsing; defaulting to match-any artifact"
          FILTER="true"
        fi

        echo "üîç Filtering artifacts by labels: $LABELS"
        echo "üßÆ Using jq filter: $FILTER"

        # Common JSON name extractor
        extract_name_from_json() {
          jq -r '
            .component.name
            // .component.displayName
            // .component.title
            // .name
            // .displayName
            // .title
            // .metadata.name
            // .data.name
            // empty
          ' "$1" 2>/dev/null || true
        }

        # Name lookup with caching and multiple strategies.
        # get_component_name <id> <artifact_name_if_any>
        get_component_name () {
          _id="$1"
          _artifact_name="${2:-}"

          # cache
          if [ -f ".cache/${_id}.name" ]; then
            cat ".cache/${_id}.name"
            return 0
          fi

          local name=""
          local s_art="0" ms_art="0"
          local s_c="0" ms_c="0"
          local s_oc="0" ms_oc="0"
          local tried_art="false" tried_c="false" tried_oc="false"

          # (A) infer from last artifactinfos body (if present)
          if [ -f response.json ]; then
            tried_art="true"
            name="$(extract_name_from_json response.json || true)"
          fi

          # (B) org-scoped endpoint (if org provided)
          if [ -z "$name" ] && [ -n "${ORG_ID:-}" ]; then
            tried_oc="true"
            read s_oc ms_oc <<EOF
$(timed_curl "$CB_API_URL/v3/organizations/${ORG_ID}/components/${_id}" comp_org.json)
EOF
            if [ "$s_oc" -eq 200 ]; then
              name="$(extract_name_from_json comp_org.json || true)"
            fi
          fi

          # (C) global endpoint
          if [ -z "$name" ]; then
            tried_c="true"
            read s_c ms_c <<EOF
$(timed_curl "$CB_API_URL/v3/components/${_id}" comp.json)
EOF
            if [ "$s_c" -eq 200 ]; then
              name="$(extract_name_from_json comp.json || true)"
            fi
          fi

          # (D) heuristic from artifact_name (if match exists and endpoint(s) failed)
          if [ -z "$name" ] && [ -n "$_artifact_name" ]; then
            # take last path segment after '/'
            name="$(printf "%s" "$_artifact_name" | awk -F'/' '{print $NF}')"
          fi

          # (E) final fallback: UUID
          if [ -z "$name" ]; then
            name="$_id"
            # Record a diagnostic note so you can see timings + statuses
            jq --arg id "$_id" \
               --arg tried_art "$tried_art" --arg tried_c "$tried_c" --arg tried_oc "$tried_oc" \
               --arg s_art "$s_art" --arg ms_art "$ms_art" \
               --arg s_c "$s_c"     --arg ms_c  "$ms_c" \
               --arg s_oc "$s_oc"   --arg ms_oc "$ms_oc" \
               '.errors += [{
                 "component_id": $id,
                 "status": 200,
                 "message": "Name lookup fell back to ID",
                 "lookup_attempts": {
                   "artifactinfos_probe": ( $tried_art == "true" ),
                   "org_components": { "tried": ( $tried_oc == "true" ), "status": ($s_oc|tonumber? // 0), "duration_ms": ($ms_oc|tonumber? // 0) },
                   "components":     { "tried": ( $tried_c  == "true" ), "status": ($s_c|tonumber?  // 0), "duration_ms": ($ms_c|tonumber?  // 0) }
                 }
               }]' \
               errors.json > tmp.json && mv tmp.json errors.json
          fi

          printf "%s" "$name" > ".cache/${_id}.name"
          printf "%s" "$name"
        }

        for COMPONENT_ID in $(echo "$COMPONENT_IDS" | tr ',' ' '); do
          echo "üì¶ Fetching for component: $COMPONENT_ID"
          read STATUS DURA <<EOF
$(timed_curl "$CB_API_URL/v3/components/$COMPONENT_ID/artifactinfos" response.json)
EOF
          echo "‚è±Ô∏è  artifactinfos: status=$STATUS duration_ms=$DURA"

          if [ "$STATUS" -ne 200 ]; then
            echo "‚ùå Component fetch failed for $COMPONENT_ID (HTTP $STATUS, ${DURA}ms)"
            # still write a manifest row
            cname="$(get_component_name "$COMPONENT_ID")"
            jq --arg id "$COMPONENT_ID" --arg name "$cname" --arg status "$STATUS" --arg dura "$DURA" \
              '.errors += [{"component_id": $id, "component_name": $name, "status": ($status | tonumber), "message": ("Component fetch failed; duration_ms=" + $dura)}]' \
              errors.json > tmp.json && mv tmp.json errors.json

            {
              echo "$COMPONENT_ID:"
              echo "  component_name: \"$cname\""
              echo "  matched: false"
              echo "  artifact_id: null"
              echo "  version: null"
              echo "  timestamp: null"
              echo "  artifact_name: null"
            } >> manifest.yaml
            continue
          fi

          MATCH=$(jq -r \
            ".artifacts // [] | .[] | select($FILTER) | \"\(.id) \(.version) \(.publishedOn) \(.name)\"" \
            response.json 2>/dev/null | head -n 1 || true)

          # Pre-derive artifact name (for heuristic naming, if needed)
          ARTIFACT_NAME=""
          if [ -n "$MATCH" ]; then
            ARTIFACT_NAME=$(printf "%s" "$MATCH" | cut -d' ' -f4-)
          fi

          COMPONENT_NAME="$(get_component_name "$COMPONENT_ID" "$ARTIFACT_NAME")"

          if [ -z "$MATCH" ]; then
            echo "‚ö†Ô∏è  No matching artifact found for $COMPONENT_ID (labels: $LABELS)"
            {
              echo "$COMPONENT_ID:"
              echo "  component_name: \"$COMPONENT_NAME\""
              echo "  matched: false"
              echo "  artifact_id: null"
              echo "  version: null"
              echo "  timestamp: null"
              echo "  artifact_name: null"
            } >> manifest.yaml

            jq --arg id "$COMPONENT_ID" --arg name "$COMPONENT_NAME" --arg labels "$LABELS" \
              '.errors += [{"component_id": $id, "component_name": $name, "status": 200, "message": ("No artifact matched labels: " + $labels)}]' \
              errors.json > tmp.json && mv tmp.json errors.json
            continue
          fi

          ARTIFACT_ID=$(printf "%s" "$MATCH" | awk '{print $1}')
          VERSION=$(printf "%s" "$MATCH" | awk '{print $2}')
          TIMESTAMP=$(printf "%s" "$MATCH" | awk '{print $3}')
          # ARTIFACT_NAME already set

          {
            echo "$COMPONENT_ID:"
            echo "  component_name: \"$COMPONENT_NAME\""
            echo "  matched: true"
            echo "  artifact_id: \"$ARTIFACT_ID\""
            echo "  version: \"$VERSION\""
            echo "  timestamp: \"$TIMESTAMP\""
            echo "  artifact_name: \"$ARTIFACT_NAME\""
          } >> manifest.yaml
        done

        # Final prints shouldn't fail the step even if some shell prints noise
        set +e
        echo "‚úÖ Final Manifest:"
        cat manifest.yaml
        echo "üìã Final Errors:"
        cat errors.json
        set -e

        # Write outputs
        cat manifest.yaml > "$CLOUDBEES_OUTPUTS/manifest"
        cat errors.json > "$CLOUDBEES_OUTPUTS/errors"
