apiVersion: automation.cloudbees.io/v1alpha1
kind: action
name: generate-artifact-manifest
description: Generates a YAML manifest of latest artifacts for a list of components.

inputs:
  cb_api_url:
    required: true
  cb_pat:
    required: true
  component_ids:
    required: true
    description: Comma-separated list of component IDs (e.g. id1,id2)
  labels:
    required: true
    description: Label filters to apply (e.g. rel=squid-ui,ns=squid-prod)
  org_id:
    required: false
    description: Optional organization ID for org-scoped component lookups
  component_overrides:
    required: false
    description: Comma-separated uuid=name pairs (e.g. "id1=nice-name,id2=other-name")
  component_overrides_json:
    required: false
    description: JSON map of uuid->name (e.g. '{"id1":"nice-name","id2":"other-name"}')

outputs:
  manifest:
    description: YAML-formatted artifact manifest with IDs, versions, timestamps, artifact names, component names, and match status
    value: ${{ steps.generate.outputs.manifest }}
  errors:
    description: JSON-formatted list of components that failed to fetch or match (with name-lookup diagnostics)
    value: ${{ steps.generate.outputs.errors }}

runs:
  using: composite
  steps:
    - id: generate
      name: Generate artifact manifest
      uses: docker://python:3.11-alpine
      shell: sh
      env:
        CB_API_URL: ${{ inputs.cb_api_url }}
        CB_PAT: ${{ inputs.cb_pat }}
        COMPONENT_IDS: ${{ inputs.component_ids }}
        LABELS: ${{ inputs.labels }}
        ORG_ID: ${{ inputs.org_id }}
        COMPONENT_OVERRIDES: ${{ inputs.component_overrides }}
        COMPONENT_OVERRIDES_JSON: ${{ inputs.component_overrides_json }}
      run: |
        set -eu
        apk add --no-cache curl jq coreutils > /dev/null

        LOG() { printf "%s\n" "$*" >&2; }

        # ---------- Build override map (.overrides.json) ----------
        echo '{}' > .overrides.json

        # A) JSON overrides (if provided)
        if [ -n "${COMPONENT_OVERRIDES_JSON:-}" ]; then
          echo "$COMPONENT_OVERRIDES_JSON" | jq -c . > .overrides.json || {
            LOG "âš ï¸  component_overrides_json is not valid JSON; ignoring"
            echo '{}' > .overrides.json
          }
        fi

        # B) pairs overrides: uuid=name,uuid2=name2 (merge into JSON)
        if [ -n "${COMPONENT_OVERRIDES:-}" ]; then
          echo "$COMPONENT_OVERRIDES" | tr ',' '\n' \
            | awk -F'=' 'NF==2 {printf "{\"%s\":\"%s\"}\n",$1,$2}' \
            | jq -s 'reduce .[] as $o ({}; . + $o)' > .pairs.json
          jq -c -s '.[0] * .[1]' .overrides.json .pairs.json > .tmp.json && mv .tmp.json .overrides.json
        fi

        LOG "ðŸ” Fetching latest artifacts for: $COMPONENT_IDS"
        LOG "ðŸ” Filtering artifacts by labels: ${LABELS:-}"
        : > manifest.yaml
        echo '{"errors":[]}' > errors.json

        # Build label filter (jq expression)
        FILTER=$(echo "${LABELS:-}" | awk -F, '
          BEGIN { first=1 }
          {
            for (i = 1; i <= NF; i++) {
              if ($i == "") continue
              split($i, kv, "=")
              if (!first) { printf " and " }
              printf "(((.labels // []) | index(\"%s=%s\")))", kv[1], kv[2]
              first=0
            }
          }')
        [ -n "$FILTER" ] || FILTER="true"
        LOG "ðŸ§® Using jq filter: $FILTER"

        # Call/resp helpers
        CALL_SEQ=0
        AI_CALLS=0; AI_TIME=0
        OC_CALLS=0; OC_TIME=0
        C_CALLS=0;  C_TIME=0
        TOTAL_TIME=0

        timed_curl() {
          _method="$1"; _url="$2"; _out="$3"
          CALL_SEQ=$((CALL_SEQ+1))
          LOG "âž¡ï¸  CALL ${CALL_SEQ}: (${_method} ${_url})"
          result="$(curl -sS -o "$_out" -w "%{http_code} %{time_total}" \
            -H "Authorization: Bearer $CB_PAT" \
            -H "Accept: application/json" \
            "$_url")"
          code="$(printf "%s" "$result" | awk '{print $1}')"
          time="$(printf "%s" "$result" | awk '{print $2}')"
          LOG "â¬…ï¸  RESP ${CALL_SEQ}: status=${code} time_s=${time} (${_method} ${_url})"
          printf "%s %s" "$code" "$time"
        }

        extract_name_from_json() {
          jq -r '
            .component.name
            // .component.displayName
            // .component.title
            // .componentName
            // .name
            // .displayName
            // .title
            // .metadata.name
            // .summary.componentName
            // .data.name
            // empty
          ' "$1" 2>/dev/null || true
        }

        # Name resolver (override -> artifact -> org -> global -> uuid)
        get_component_name() {
          _id="$1"
          _artifact_name="${2:-}"

          # 0) Override?
          o="$(jq -r --arg id "$_id" '.[$id] // empty' .overrides.json)"
          if [ -n "$o" ] && [ "$o" != "null" ]; then
            LOG "â„¹ï¸  Component name source for ${_id}: override -> ${o}"
            printf "%s" "$o"
            return 0
          fi

          name=""; source=""

          # 1) From the last artifactinfos body if present
          if [ -f response.json ]; then
            n1="$(extract_name_from_json response.json)"
            if [ -n "$n1" ]; then name="$n1"; source="artifactinfos_body"; fi
          fi

          # 2) org components (if org_id provided)
          oc_code="0"; oc_time="0"
          if [ -z "$name" ] && [ -n "${ORG_ID:-}" ]; then
            oc_line="$(timed_curl GET "$CB_API_URL/v3/organizations/${ORG_ID}/components/${_id}" comp_org.json)"
            oc_code="$(printf "%s" "$oc_line" | awk '{print $1}')"
            oc_time="$(printf "%s" "$oc_line" | awk '{print $2}')"
            TOTAL_TIME=$(awk "BEGIN{print $TOTAL_TIME + $oc_time}")
            OC_CALLS=$((OC_CALLS+1))
            OC_TIME=$(awk "BEGIN{print $OC_TIME + $oc_time}")
            if [ "$oc_code" = "200" ]; then
              n2="$(extract_name_from_json comp_org.json)"
              if [ -n "$n2" ]; then name="$n2"; source="org_components"; fi
            fi
          fi

          # 3) global components
          c_code="0"; c_time="0"
          if [ -z "$name" ]; then
            c_line="$(timed_curl GET "$CB_API_URL/v3/components/${_id}" comp.json)"
            c_code="$(printf "%s" "$c_line" | awk '{print $1}')"
            c_time="$(printf "%s" "$c_line" | awk '{print $2}')"
            TOTAL_TIME=$(awk "BEGIN{print $TOTAL_TIME + $c_time}")
            C_CALLS=$((C_CALLS+1))
            C_TIME=$(awk "BEGIN{print $C_TIME + $c_time}")
            if [ "$c_code" = "200" ]; then
              n3="$(extract_name_from_json comp.json)"
              if [ -n "$n3" ]; then name="$n3"; source="components"; fi
            fi
          fi

          # 4) heuristic from artifact name (repo/image path -> tail)
          if [ -z "$name" ] && [ -n "$_artifact_name" ]; then
            n4="$(printf "%s" "$_artifact_name" | awk -F'/' '{print $NF}')"
            if [ -n "$n4" ]; then name="$n4"; source="artifact_heuristic"; fi
          fi

          # 5) fallback to UUID with diagnostics
          if [ -z "$name" ]; then
            name="$_id"; source="uuid"
            jq --arg id "$_id" \
               --arg oc_code "${oc_code:-0}" --arg oc_time "${oc_time:-0}" \
               --arg c_code  "${c_code:-0}"  --arg c_time  "${c_time:-0}" \
               '.errors += [{
                 "component_id": $id,
                 "status": 200,
                 "message": "Name lookup fell back to ID",
                 "lookup_attempts": {
                   "org_components": { "status": ($oc_code|tonumber? // 0), "time_s": ($oc_time|tonumber? // 0) },
                   "components":     { "status": ($c_code|tonumber?  // 0), "time_s": ($c_time|tonumber?  // 0) }
                 }
               }]' \
               errors.json > tmp.json && mv tmp.json errors.json
          fi

          LOG "â„¹ï¸  Component name source for ${_id}: ${source} -> ${name}"
          printf "%s" "$name"
        }

        # ---------- Main loop ----------
        IFS_SAVE="$IFS"
        IFS=','; set -- $COMPONENT_IDS; IFS="$IFS_SAVE"

        for COMPONENT_ID in "$@"; do
          LOG "ðŸ“¦ Fetching for component: $COMPONENT_ID"
          LOG "   (GET $CB_API_URL/v3/components/$COMPONENT_ID/artifactinfos)"

          ai_line="$(timed_curl GET "$CB_API_URL/v3/components/$COMPONENT_ID/artifactinfos" response.json)"
          ai_code="$(printf "%s" "$ai_line" | awk '{print $1}')"
          ai_time="$(printf "%s" "$ai_line" | awk '{print $2}')"
          TOTAL_TIME=$(awk "BEGIN{print $TOTAL_TIME + $ai_time}")
          AI_CALLS=$((AI_CALLS+1))
          AI_TIME=$(awk "BEGIN{print $AI_TIME + $ai_time}")

          # try to capture a candidate artifact name early for heuristic
          MATCH=$(jq -r ".artifacts // [] | .[] | select($FILTER) | \"\(.id) \(.version) \(.publishedOn) \(.name)\"" response.json 2>/dev/null | head -n 1 || true)
          ARTIFACT_NAME=""
          [ -n "$MATCH" ] && ARTIFACT_NAME="$(printf "%s" "$MATCH" | cut -d' ' -f4-)"

          COMPONENT_NAME="$(get_component_name "$COMPONENT_ID" "$ARTIFACT_NAME")"

          if [ "$ai_code" != "200" ]; then
            jq --arg id "$COMPONENT_ID" --arg name "$COMPONENT_NAME" --arg code "$ai_code" --arg t "$ai_time" \
              '.errors += [{"component_id": $id, "component_name": $name, "status": ($code | tonumber), "message": ("Component fetch failed; time_s=" + $t)}]' \
              errors.json > tmp.json && mv tmp.json errors.json
            {
              echo "$COMPONENT_ID:"
              echo "  component_name: \"$COMPONENT_NAME\""
              echo "  matched: false"
              echo "  artifact_id: null"
              echo "  version: null"
              echo "  timestamp: null"
              echo "  artifact_name: null"
            } >> manifest.yaml
            continue
          fi

          if [ -z "$MATCH" ]; then
            {
              echo "$COMPONENT_ID:"
              echo "  component_name: \"$COMPONENT_NAME\""
              echo "  matched: false"
              echo "  artifact_id: null"
              echo "  version: null"
              echo "  timestamp: null"
              echo "  artifact_name: null"
            } >> manifest.yaml
            jq --arg id "$COMPONENT_ID" --arg name "$COMPONENT_NAME" --arg labels "${LABELS:-}" \
              '.errors += [{"component_id": $id, "component_name": $name, "status": 200, "message": ("No artifact matched labels: " + $labels)}]' \
              errors.json > tmp.json && mv tmp.json errors.json
            continue
          fi

          ARTIFACT_ID="$(printf "%s" "$MATCH" | awk '{print $1}')"
          VERSION="$(printf "%s" "$MATCH" | awk '{print $2}')"
          TIMESTAMP="$(printf "%s" "$MATCH" | awk '{print $3}')"

          {
            echo "$COMPONENT_ID:"
            echo "  component_name: \"$COMPONENT_NAME\""
            echo "  matched: true"
            echo "  artifact_id: \"$ARTIFACT_ID\""
            echo "  version: \"$VERSION\""
            echo "  timestamp: \"$TIMESTAMP\""
            echo "  artifact_name: \"$ARTIFACT_NAME\""
          } >> manifest.yaml
        done

        # Summary (stderr only)
        LOG "ðŸ“ˆ API CALL SUMMARY"
        LOG "  artifactinfos: calls=${AI_CALLS}, total_time_s=${AI_TIME}"
        LOG "  org/components: calls=${OC_CALLS}, total_time_s=${OC_TIME}"
        LOG "  components:     calls=${C_CALLS}, total_time_s=${C_TIME}"
        LOG "  overall_total_time_s=${TOTAL_TIME}"

        # Outputs
        cat manifest.yaml > "$CLOUDBEES_OUTPUTS/manifest"
        cat errors.json > "$CLOUDBEES_OUTPUTS/errors"
